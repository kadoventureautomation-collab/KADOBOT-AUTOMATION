import random
import time
import threading
import json
import os
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.action_chains import ActionChains
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import undetected_chromedriver as uc
from fake_useragent import UserAgent
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed

class KADOVENTUREAutomation:
    def __init__(self, config_file="config.json"):
        self.config = self.load_config(config_file)
        self.accounts = self.config.get("accounts", [])
        self.proxies = self.config.get("proxies", [])
        self.user_agents = self.load_user_agents()
        self.comment_files = self.config.get("comment_files", [])
        self.active_threads = 0
        self.max_threads = self.config.get("max_threads", 5)
        
    def load_config(self, config_file):
        """Load configuration from JSON file"""
        if os.path.exists(config_file):
            with open(config_file, 'r') as f:
                return json.load(f)
        return {
            "accounts": [],
            "proxies": [],
            "max_threads": 5,
            "min_view_time": 60,
            "max_view_time": 300,
            "min_delay": 3,
            "max_delay": 10,
            "comment_files": ["comments.txt"]
        }
    
    def load_user_agents(self):
        """Load user agents from file or generate them"""
        ua = UserAgent()
        agents = []
        for _ in range(20):  # Generate 20 random user agents
            agents.append(ua.random)
        return agents
    
    def get_random_user_agent(self):
        """Get a random user agent"""
        return random.choice(self.user_agents)
    
    def get_random_proxy(self):
        """Get a random proxy from the list"""
        if self.proxies:
            return random.choice(self.proxies)
        return None
    
    def get_random_delay(self):
        """Get a random delay between actions"""
        return random.uniform(self.config.get("min_delay", 3), 
                             self.config.get("max_delay", 10))
    
    def get_random_view_time(self):
        """Get a random view time for videos"""
        return random.randint(self.config.get("min_view_time", 60), 
                             self.config.get("max_view_time", 300))
    
    def setup_driver(self, account=None, use_profile=False):
        """Set up Chrome driver with custom options"""
        chrome_options = Options()
        
        # Set random user agent
        chrome_options.add_argument(f'--user-agent={self.get_random_user_agent()}')
        
        # Proxy settings
        proxy = self.get_random_proxy()
        if proxy:
            chrome_options.add_argument(f'--proxy-server={proxy}')
        
        # Other options to make browser look more human
        chrome_options.add_argument('--disable-blink-features=AutomationControlled')
        chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        chrome_options.add_experimental_option('useAutomationExtension', False)
        chrome_options.add_argument('--disable-dev-shm-usage')
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-gpu')
        chrome_options.add_argument('--start-maximized')
        
        # Use undetected chromedriver to avoid detection
        try:
            driver = uc.Chrome(options=chrome_options)
        except:
            # Fallback to regular Chrome driver
            driver = webdriver.Chrome(options=chrome_options)
        
        # Execute CDP commands to prevent detection
        driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        driver.execute_cdp_cmd('Network.setUserAgentOverride', {
            "userAgent": driver.execute_script("return navigator.userAgent;").replace("Headless", "")})
        
        return driver
    
    def human_like_mouse_movement(self, driver, element):
        """Simulate human-like mouse movement to an element"""
        action = ActionChains(driver)
        try:
            # Move to element with slight offset and human-like path
            action.move_to_element_with_offset(element, 
                                             random.randint(-5, 5), 
                                             random.randint(-5, 5))
            action.perform()
            time.sleep(random.uniform(0.2, 0.5))
        except:
            # Fallback to direct click if movement fails
            element.click()
    
    def human_like_scroll(self, driver, scroll_amount=None):
        """Simulate human-like scrolling"""
        if scroll_amount is None:
            scroll_amount = random.randint(200, 800)
        
        # Scroll in a human-like manner (not all at once)
        for i in range(0, scroll_amount, random.randint(20, 50)):
            driver.execute_script(f"window.scrollBy(0, {random.randint(10, 30)});")
            time.sleep(random.uniform(0.1, 0.3))
    
    def human_like_typing(self, element, text):
        """Simulate human-like typing"""
        for char in text:
            element.send_keys(char)
            time.sleep(random.uniform(0.05, 0.2))
    
    def login_with_gmail(self, driver, email, password):
        """Login to YouTube with Gmail credentials"""
        try:
            driver.get("https://accounts.google.com/signin/v2/identifier?service=youtube&continue=https%3A%2F%2Fwww.youtube.com%2Fsignin%3Fnext%3D%252F%26action_handle_signin%3Dtrue%26hl%3Den%26app%3Ddesktop%26hl%3Den&passive=true&hl=en&flowName=GlifWebSignIn&flowEntry=ServiceIframe")
            
            # Wait for email field and enter email
            email_field = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "identifierId"))
            )
            self.human_like_typing(email_field, email)
            email_field.send_keys(Keys.RETURN)
            time.sleep(self.get_random_delay())
            
            # Wait for password field and enter password
            password_field = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.NAME, "password"))
            )
            self.human_like_typing(password_field, password)
            password_field.send_keys(Keys.RETURN)
            time.sleep(self.get_random_delay())
            
            # Check if login was successful
            WebDriverWait(driver, 15).until(
                EC.presence_of_element_located((By.ID, "avatar-btn"))
            )
            return True
        except Exception as e:
            print(f"Login failed: {str(e)}")
            return False
    
    def watch_video(self, driver, video_url, watch_time=None):
        """Watch a video for a specified amount of time"""
        if watch_time is None:
            watch_time = self.get_random_view_time()
        
        try:
            driver.get(video_url)
            time.sleep(5)  # Wait for page to load
            
            # Play video if not autoplaying
            try:
                play_button = driver.find_element(By.CSS_SELECTOR, "button.ytp-play-button")
                if "Play" in play_button.get_attribute("aria-label"):
                    play_button.click()
            except:
                pass
            
            # Simulate human-like behavior while watching
            start_time = time.time()
            while time.time() - start_time < watch_time:
                # Random interactions during viewing
                if random.random() < 0.3:  # 30% chance of interaction
                    # Random scroll
                    if random.random() < 0.5:
                        self.human_like_scroll(driver, random.randint(100, 300))
                    
                    # Random pause/play
                    if random.random() < 0.2:
                        try:
                            play_button = driver.find_element(By.CSS_SELECTOR, "button.ytp-play-button")
                            play_button.click()
                            time.sleep(random.uniform(1, 3))
                            play_button.click()
                        except:
                            pass
                
                # Small random wait between interactions
                time.sleep(random.uniform(2, 5))
            
            return True
        except Exception as e:
            print(f"Error watching video: {str(e)}")
            return False
    
    def search_and_watch(self, driver, keyword, watch_time=None):
        """Search for a video by keyword and watch it"""
        try:
            driver.get("https://www.youtube.com")
            time.sleep(3)
            
            # Find search box and enter keyword
            search_box = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.NAME, "search_query"))
            )
            self.human_like_typing(search_box, keyword)
            search_box.send_keys(Keys.RETURN)
            time.sleep(3)
            
            # Click on a random video from search results
            video_links = driver.find_elements(By.ID, "video-title")
            if video_links:
                random_video = random.choice(video_links[:5])  # Choose from top 5 results
                video_url = random_video.get_attribute("href")
                return self.watch_video(driver, video_url, watch_time)
            return False
        except Exception as e:
            print(f"Search and watch failed: {str(e)}")
            return False
    
    def like_video(self, driver):
        """Like the current video"""
        try:
            like_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label*='like this video']"))
            )
            self.human_like_mouse_movement(driver, like_button)
            like_button.click()
            time.sleep(self.get_random_delay())
            return True
        except Exception as e:
            print(f"Like failed: {str(e)}")
            return False
    
    def comment_on_video(self, driver, comment_text=None):
        """Comment on the current video"""
        if comment_text is None:
            comment_text = self.get_random_comment()
            
        try:
            # Scroll to comments section
            self.human_like_scroll(driver, 800)
            time.sleep(2)
            
            # Find comment box
            comment_box = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "div#placeholder-area"))
            )
            self.human_like_mouse_movement(driver, comment_box)
            comment_box.click()
            time.sleep(1)
            
            # Type comment
            comment_input = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "div#contenteditable-root"))
            )
            self.human_like_typing(comment_input, comment_text)
            time.sleep(1)
            
            # Submit comment
            submit_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button#submit-button"))
            )
            submit_button.click()
            time.sleep(self.get_random_delay())
            return True
        except Exception as e:
            print(f"Comment failed: {str(e)}")
            return False
    
    def get_random_comment(self):
        """Get a random comment from comment files with spin syntax support"""
        if not self.comment_files:
            return "Great video! Thanks for sharing."
        
        # Select a random comment file
        comment_file = random.choice(self.comment_files)
        comments = []
        
        try:
            with open(comment_file, 'r', encoding='utf-8') as f:
                comments = f.read().splitlines()
        except:
            comments = ["Nice video!", "Thanks for the content!", "Great stuff!"]
        
        if not comments:
            return "Awesome video!"
        
        # Select a random comment and process spin syntax
        comment = random.choice(comments)
        return self.process_spin_syntax(comment)
    
    def process_spin_syntax(self, text):
        """Process spin syntax like {option1|option2} in text"""
        import re
        pattern = r'\{([^{}]+)\}'
        
        def replace(match):
            options = match.group(1).split('|')
            return random.choice(options)
        
        return re.sub(pattern, replace, text)
    
    def subscribe_to_channel(self, driver):
        """Subscribe to the current channel"""
        try:
            subscribe_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label*='Subscribe to']"))
            )
            self.human_like_mouse_movement(driver, subscribe_button)
            subscribe_button.click()
            time.sleep(self.get_random_delay())
            return True
        except Exception as e:
            print(f"Subscribe failed: {str(e)}")
            return False
    
    def run_account_session(self, account, tasks):
        """Run a session for a single account with specified tasks"""
        driver = None
        try:
            print(f"Starting session for account: {account['email']}")
            driver = self.setup_driver(account)
            
            # Login if credentials provided
            if 'email' in account and 'password' in account:
                if not self.login_with_gmail(driver, account['email'], account['password']):
                    print(f"Login failed for {account['email']}")
                    return False
            
            # Execute tasks
            for task in tasks:
                task_type = task.get('type')
                
                if task_type == 'watch_video':
                    self.watch_video(driver, task['url'], task.get('duration'))
                
                elif task_type == 'search_and_watch':
                    self.search_and_watch(driver, task['keyword'], task.get('duration'))
                
                elif task_type == 'like_video':
                    self.like_video(driver)
                
                elif task_type == 'comment':
                    self.comment_on_video(driver, task.get('comment'))
                
                elif task_type == 'subscribe':
                    self.subscribe_to_channel(driver)
                
                # Random delay between tasks
                time.sleep(self.get_random_delay())
            
            print(f"Session completed for account: {account['email']}")
            return True
            
        except Exception as e:
            print(f"Session failed for {account['email']}: {str(e)}")
            return False
        finally:
            if driver:
                driver.quit()
    
    def run_campaign(self, campaign_config):
        """Run a complete campaign with multiple accounts and tasks"""
        accounts = campaign_config.get('accounts', self.accounts)
        tasks = campaign_config.get('tasks', [])
        max_threads = campaign_config.get('max_threads', self.max_threads)
        
        print(f"Starting campaign with {len(accounts)} accounts and {len(tasks)} tasks")
        
        # Use ThreadPoolExecutor for multi-threading
        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            # Submit all account sessions
            future_to_account = {
                executor.submit(self.run_account_session, account, tasks): account 
                for account in accounts
            }
            
            # Wait for all sessions to complete
            for future in as_completed(future_to_account):
                account = future_to_account[future]
                try:
                    result = future.result()
                    if result:
                        print(f"Account {account['email']} completed successfully")
                    else:
                        print(f"Account {account['email']} failed")
                except Exception as e:
                    print(f"Account {account['email']} generated an exception: {str(e)}")
        
        print("Campaign completed")

# Example usage
if __name__ == "__main__":
    # Create a sample configuration
    config = {
        "accounts": [
            {"email": "account1@gmail.com", "password": "password1"},
            {"email": "account2@gmail.com", "password": "password2"}
        ],
        "proxies": [
            "proxy1:port",
            "proxy2:port"
        ],
        "max_threads": 3,
        "min_view_time": 60,
        "max_view_time": 180,
        "min_delay": 2,
        "max_delay": 8,
        "comment_files": ["comments.txt"]
    }
    
    # Save config to file
    with open("config.json", "w") as f:
        json.dump(config, f, indent=4)
    
    # Create bot instance
    bot = KADOVENTUREAutomation("config.json")
    
    # Define campaign tasks
    campaign = {
        "accounts": config["accounts"],
        "tasks": [
            {"type": "search_and_watch", "keyword": "python programming", "duration": 120},
            {"type": "like_video"},
            {"type": "comment"},
            {"type": "watch_video", "url": "https://www.youtube.com/watch?v=example1", "duration": 90},
            {"type": "subscribe"}
        ],
        "max_threads": 2
    }
    
    # Run the campaign
    bot.run_campaign(campaign)
